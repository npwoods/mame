// license:BSD-3-Clause
// copyright-holders:Nathan Woods
/***************************************************************************

    coco3.cpp

    TRS-80 Radio Shack Color Computer 3

  Functions to emulate general aspects of the machine (RAM, ROM, interrupts,
  I/O ports)

  The Dragon/CoCo2 have two PIAs.  These PIAs can trigger interrupts.  PIA0
  is set up to trigger IRQ on the CPU, and PIA1 can trigger FIRQ.  Each PIA
  has two output lines, and an interrupt will be triggered if either of these
  lines are asserted.

  -----  IRQ
  6809 |-<----------- PIA0
       |
       |
       |
       |
       |
       |-<----------- PIA1
  -----

  The CoCo 3 still supports these interrupts, but the GIME can chose whether
  "old school" interrupts are generated, or the new ones generated by the GIME

  -----  IRQ
  6809 |-<----------- PIA0
       |       |                ------
       |       -<-------<-------|    |
       |                        |GIME|
       |       -<-------<-------|    |
       | FIRQ  |                ------
       |-<----------- PIA1
  -----

  In an email discussion with JK, he informs me that when GIME interrupts are
  enabled, this actually does not prevent PIA interrupts.  Apparently JeffV's
  CoCo 3 emulator did not handle this properly.

***************************************************************************/

#include "emu.h"
#include "includes/coco3.h"

//-------------------------------------------------
//  ff20_write
//-------------------------------------------------

WRITE8_MEMBER( coco3_state::ff20_write )
{
	coco_state::ff20_write(space, offset, data, mem_mask);

	if (offset == 0x02)
		m_gime->ff22_write(data);
}



//-------------------------------------------------
//  ff40_read
//-------------------------------------------------

READ8_MEMBER( coco3_state::ff40_read )
{
	uint8_t result = 0x00;
	if (m_gime->spare_chip_select_enabled())
		result = coco_state::ff40_read(space, offset, mem_mask);
	return result;
}



//-------------------------------------------------
//  ff40_write
//-------------------------------------------------

WRITE8_MEMBER( coco3_state::ff40_write )
{
	if (m_gime->spare_chip_select_enabled())
		coco_state::ff40_write(space, offset, data, mem_mask);
}



//-------------------------------------------------
//  firq_get_line
//-------------------------------------------------

bool coco3_state::firq_get_line(void)
{
	return coco_state::firq_get_line() || m_gime->firq_r();
}



//-------------------------------------------------
//  irq_get_line
//-------------------------------------------------

bool coco3_state::irq_get_line(void)
{
	return coco_state::irq_get_line() || m_gime->irq_r();
}



//-------------------------------------------------
//  update_keyboard_input
//-------------------------------------------------

void coco3_state::update_keyboard_input(uint8_t value, uint8_t z)
{
	coco_state::update_keyboard_input(value, z);
	m_gime->set_il1(value == 0xFF);
}



//-------------------------------------------------
//  cart_w
//-------------------------------------------------

void coco3_state::cart_w(bool state)
{
	coco_state::cart_w(state);
	m_gime->set_il0(state);
}



//-------------------------------------------------
//  update_cart_base
//-------------------------------------------------

void coco3_state::update_cart_base(uint8_t *cart_base)
{
	m_gime->update_cart_rom();
}



//-------------------------------------------------
//  screen_update
//-------------------------------------------------

uint32_t coco3_state::screen_update(screen_device &screen, bitmap_rgb32 &bitmap, const rectangle &cliprect)
{
	bool result;
	if (!strcmp(screen.tag(), ":" COMPOSITE_SCREEN_TAG))
	{
		/* composite screen */
		result = m_gime->update_composite(bitmap, cliprect);
	}
	else if (!strcmp(screen.tag(), ":" RGB_SCREEN_TAG))
	{
		/* rgb screen */
		result = m_gime->update_rgb(bitmap, cliprect);
	}
	else
	{
		fatalerror("Called screen_update() with invalid tag '%s'\n", screen.tag());
	}
	return result;
}


//-------------------------------------------------
//  conditionally_reinstall_bank
//-------------------------------------------------

void coco3_state::conditionally_reinstall_bank(uint16_t changed_addrstart, uint16_t changed_addrend, bool read_changed, bool write_changed,
	uint16_t bank_addrstart, uint16_t bank_addrend, const char *rbank, const char *wbank)
{
	if (changed_addrend >= bank_addrstart && changed_addrstart <= bank_addrend)
	{
		if (read_changed)
		{
			cpu_address_space().install_read_bank(bank_addrstart, bank_addrend, rbank);
			update_shadow(bank_addrstart, bank_addrend, read_or_write::READ);
		}
		if (write_changed)
		{
			cpu_address_space().install_write_bank(bank_addrstart, bank_addrend, wbank);
			update_shadow(bank_addrstart, bank_addrend, read_or_write::WRITE);
		}
	}
}


//-------------------------------------------------
//  conditionally_reinstall_handler
//-------------------------------------------------

void coco3_state::conditionally_reinstall_handler(uint16_t changed_addrstart, uint16_t changed_addrend, bool read_changed, bool write_changed,
	uint16_t handler_addrstart, uint16_t handler_addrend, read8_delegate rh, write8_delegate wh)
{
	if (changed_addrend >= handler_addrstart && changed_addrstart <= handler_addrend)
	{
		if (read_changed)
		{
			cpu_address_space().install_read_handler(handler_addrstart, handler_addrend, rh);
			update_shadow(handler_addrstart, handler_addrend, read_or_write::READ);
		}
		if (write_changed)
		{
			cpu_address_space().install_write_handler(handler_addrstart, handler_addrend, wh);
			update_shadow(handler_addrstart, handler_addrend, read_or_write::WRITE);
		}
	}
}


//-------------------------------------------------
//  shadow_changed
//-------------------------------------------------

void coco3_state::shadow_changed(uint16_t addrstart, uint16_t addrend, bool read_changed, bool write_changed)
{
	conditionally_reinstall_bank(addrstart, addrend, read_changed, write_changed, 0x0000, 0x1FFF, "rbank0", "wbank0");
	conditionally_reinstall_bank(addrstart, addrend, read_changed, write_changed, 0x2000, 0x3FFF, "rbank1", "wbank1");
	conditionally_reinstall_bank(addrstart, addrend, read_changed, write_changed, 0x4000, 0x5FFF, "rbank2", "wbank2");
	conditionally_reinstall_bank(addrstart, addrend, read_changed, write_changed, 0x6000, 0x7FFF, "rbank3", "wbank3");
	conditionally_reinstall_bank(addrstart, addrend, read_changed, write_changed, 0x8000, 0x9FFF, "rbank4", "wbank4");
	conditionally_reinstall_bank(addrstart, addrend, read_changed, write_changed, 0xA000, 0xAFFF, "rbank5", "wbank5");
	conditionally_reinstall_bank(addrstart, addrend, read_changed, write_changed, 0xC000, 0xDFFF, "rbank6", "wbank6");
	conditionally_reinstall_bank(addrstart, addrend, read_changed, write_changed, 0xE000, 0xFDFF, "rbank7", "wbank7");
	conditionally_reinstall_bank(addrstart, addrend, read_changed, write_changed, 0xFE00, 0xFEFF, "rbank8", "wbank8");
	conditionally_reinstall_handler(addrstart, addrend, read_changed, write_changed, 0xFF00, 0xFF1F, read8_delegate(FUNC(coco_state::ff00_read), this), write8_delegate(FUNC(coco_state::ff00_write), this));
	conditionally_reinstall_handler(addrstart, addrend, read_changed, write_changed, 0xFF20, 0xFF3F, read8_delegate(FUNC(coco_state::ff20_read), this), write8_delegate(FUNC(coco_state::ff20_write), this));
	conditionally_reinstall_handler(addrstart, addrend, read_changed, write_changed, 0xFF40, 0xFF5F, read8_delegate(FUNC(coco_state::ff40_read), this), write8_delegate(FUNC(coco_state::ff40_write), this));
	conditionally_reinstall_handler(addrstart, addrend, read_changed, write_changed, 0xFF90, 0xFFDF, read8_delegate(FUNC(gime_device::read), &*m_gime), write8_delegate(FUNC(gime_device::write), &*m_gime));
}
